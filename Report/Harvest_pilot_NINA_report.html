<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Experimental harvest of ptarmigan, black grouse and capercaillie:</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Harvest_pilot_NINA_report_files/libs/clipboard/clipboard.min.js"></script>
<script src="Harvest_pilot_NINA_report_files/libs/quarto-html/quarto.js"></script>
<script src="Harvest_pilot_NINA_report_files/libs/quarto-html/popper.min.js"></script>
<script src="Harvest_pilot_NINA_report_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Harvest_pilot_NINA_report_files/libs/quarto-html/anchor.min.js"></script>
<link href="Harvest_pilot_NINA_report_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Harvest_pilot_NINA_report_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Harvest_pilot_NINA_report_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Harvest_pilot_NINA_report_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Harvest_pilot_NINA_report_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Experimental harvest of ptarmigan, black grouse and capercaillie:</h1>
<p class="subtitle lead">Summary of planning stage</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  
<div>
  <div class="abstract">
    <div class="block-title">Abstract</div>
    Tekst inn her, et kort resymé av innholdet. Teksten i sammendraget er søkbar i databaser og på nett, og er viktig for at rapporten skal fanges opp ved søk.
  </div>
</div>


</header>


<section id="inl" class="level1">
<h1>Introduction</h1>
<p>ERLEND ADD TEXT HERE….</p>
<p>In this report, we will present the results from the planning stage of the project. It includes two main sections: i) a systamatic mapping of the litterature related to effects of harvest on galliformes, and ii) a thorough evaluation of the experimental design including both the sampling of study subjects and assignment of treatment levels.</p>
</section>
<section id="systematic-mapping-of-the-literature" class="level1">
<h1>Systematic mapping of the literature</h1>
<p>This systematic map is produced as part of the preparation of a large-scale harvest experiment in Norway outlined above. The protocol was prepared prior to conducting the search. Here, we include the relevant information and report any deviation from the protocol.</p>
<section id="objective-of-the-review" class="level2">
<h2 class="anchored" data-anchor-id="objective-of-the-review">Objective of the review &nbsp;</h2>
<p>The main objective of this review is to map the available literature on effects of managed harvest/hunting on galliform species.&nbsp;&nbsp;</p>
<section id="research-question" class="level3">
<h3 class="anchored" data-anchor-id="research-question">Research question&nbsp;&nbsp;</h3>
<p>What is the effect of managed harvest/hunting on Galliformes?&nbsp;</p>
</section>
</section>
<section id="methods" class="level2">
<h2 class="anchored" data-anchor-id="methods">Methods&nbsp;</h2>
<section id="search-for-articles" class="level3">
<h3 class="anchored" data-anchor-id="search-for-articles">Search for articles&nbsp;</h3>
<p>We used a PIO (Population, Intervention, Outcome) question structure to help develop the search strategy.&nbsp;&nbsp;</p>
<ul>
<li><p>Population (P): Bird species within the order Galliformes&nbsp;</p></li>
<li><p>Intervention (I): Legal (managed) hunting or harvest&nbsp;</p></li>
<li><p>Outcome (O): The&nbsp; ecological impacts, population dynamics, or behaviours related to hunting/harvesting.&nbsp;</p></li>
</ul>
<p>We searched for academic literature (publications) in two search platforms; Web of Science and lens.org. Specifically, we will search the Web of Science Core Collection (WOS.SCI: 1987 to 2025, WOS.AHCI: 1987 to 2025, WOS.ESCI: 2020 to 2025 and WOS.SSCI: 1987 to 2025) using the NINA library subscription using the following search string:&nbsp;</p>
<p>((TS=(galliform* OR grouse OR ptarmigan OR Phasianidae OR pheasant OR “lagopus lagopus” OR “lagopus mura” OR “wild turkey” OR “bobwhite” OR partridge))&nbsp;</p>
<p>AND (TS=(“hunt” OR “harvest”)))&nbsp;</p>
<p>AND SU=(“Ecology” OR “Wildlife” OR “Environment”)&nbsp;</p>
<p>For lens.org we will use the following search string:&nbsp;</p>
<p>(abstract:(“galliform” OR “grouse” OR “ptarmigan” OR “Phasianidae” OR “pheasant” OR “lagopus lagopus” OR “lagopus mura” OR “wild turkey” OR “bobwhite” OR “partridge”) OR title:(“galliform” OR “grouse” OR “ptarmigan” OR “Phasianidae” OR “pheasant” OR “lagopus lagopus” OR “lagopus mura” OR “wild turkey” OR “bobwhite” OR “partridge”)) AND abstract:(“hunt” OR “harvest”) OR title:(“hunt” OR “harvest”) AND field_of_study:(“Ecology” OR “Wildlife” OR “Environment”)&nbsp;</p>
<p>In addition, a backward and forward citation chasing (using CitationChaser) was performed based on the three first benchmark papers listed below (Sandercock et al.&nbsp;2011; Pedersen et al.&nbsp;2004; Sedinger &amp; Rotella 2005). &nbsp;</p>
</section>
<section id="benchmark-papers" class="level3">
<h3 class="anchored" data-anchor-id="benchmark-papers">Benchmark papers&nbsp;</h3>
<p>The following benchmark papers was used to assess the effectiveness of the search string. We expected to find all these papers in a review of this question. We recorded if each benchmark paper is found in the searches (WoS and lens.org).&nbsp;&nbsp;</p>
<ul>
<li><p>Sandercock, B. K., E. B. Nilsen, H. Brøseth, and H. C. Pedersen. 2011. Is hunting mortality additive or compensatory to natural mortality? Effects of experimental harvest on the survival and cause-specific mortality of willow ptarmigan. Journal of Animal Ecology 80:244-258.&nbsp;</p></li>
<li><p>Pedersen, H. C., H. Steen, L. Kastdalen, H. Brøseth, R. A. Ims, W. Svendsen, and N. G. Yoccoz. 2004. Weak compensation of harvest despite strong density-dependent growth in willow ptarmigan. Proceedings of the Royal Society of London Series B-Biological Sciences 271:381-385.&nbsp;</p></li>
<li><p>Sedinger, J.S. &amp; Rotella, J.J. 2005. Effect of harvest on sage-grouse Centrocercus urophasianus populations: what can we learn from the current data? Wildlife Biology, 11, 371–375.&nbsp;</p></li>
<li><p>Pedersen, Å. Ø., E. M. Soininen, S. Unander, M. H. Willebrand, and E. Fuglei. 2014. Experimental harvest reveals the importance of territoriality in limiting the breeding population of Svalbard rock ptarmigan. European Journal of Wildlife Research 60:201-212.&nbsp;</p></li>
<li><p>Brøseth, H., J. Tufto, H. C. Pedersen, H. Steen, and L. Kastdalen. 2005. Dispersal patterns in a harvested willow ptarmigan population. Journal of Applied Ecology 42:453-459.&nbsp;</p></li>
<li><p>Brøseth, H., E. B. Nilsen, and H. C. Pedersen. 2012. Temporal quota corrections based on timing of harvest in a small game species. European Journal of Wildlife Research 58:797-802.&nbsp;</p></li>
<li><p>Brøseth, H., and H. C. Pedersen. 2000. Hunting effort and game vulnerability studies on a small scale: a new technique combining radio-telemetry, GPS and GIS. Journal of Applied Ecology 37:182-190.&nbsp;</p></li>
<li><p>Henden, J.-A., R. A. Ims, N. G. Yoccoz, E. J. Asbjørnsen, A. Stien, J. P. Mellard, T. Tveraa, F. Marolla, and J. U. Jepsen. 2020. End-user involvement to improve predictions and management of populations with complex dynamics and multiple drivers. Ecological Applications n/a:e02120.&nbsp;</p></li>
<li><p>Small, R.J., Holzwart, J.C. &amp; Rusch, D.H. 1991. Predation and hunting mortality of ruffed grouse in central Wisconsin. Journal of Wildlife Management, 55, 512–520.&nbsp;</p></li>
</ul>
</section>
</section>
<section id="article-screening" class="level2">
<h2 class="anchored" data-anchor-id="article-screening">Article screening&nbsp;&nbsp;</h2>
<p>We used pre-determined inclusion/exclusion criteria when screening eligible studies. Excluded papers will be shown in a flowchart using the ROSES flow chart (Haddaway et al.&nbsp;2020). Included studies was de-duplicated based on DOI and title matches using the deduplication tool in Rayyan.&nbsp;&nbsp;</p>
<p>After de-duplication, title and abstract screening was done using the eligibility criteria. If uncertainty remained, the full text version was visited to confirm/reject. The screening was done using Rayyan. A set of XX papers was reviewed by three members of the review team to ensure consistency.&nbsp;&nbsp;</p>
<section id="eligibility-criteria" class="level3">
<h3 class="anchored" data-anchor-id="eligibility-criteria">Eligibility criteria&nbsp;</h3>
<p>We reviewed scientific articles from all parts of the world. We included papers covering all galliform species. Studies of both native and introduced populations were eligible. Studies of all spatial scales and across all relevant ecosystems were considered eligible. Only studies documenting the effects of legal and/or managed harvest on galliform populations were eligible. Studies of poaching were not eligible. The effects must be assessed quantitatively for the study to be eligible. Eligible outcomes included effects of harvest on population abundance, density, sex- and age structure, recruitment, survival, behaviour, genetic, physiology and distribution. Studies focusing on lead (or heavy metal) poisoning or content in wild birds from shooting were not eligible. Both observational and experimental study designs are eligible. Mathematical simulation studies are eligible.&nbsp;&nbsp;&nbsp;&nbsp;</p>
</section>
<section id="title-and-abstract-screening-stage" class="level3">
<h3 class="anchored" data-anchor-id="title-and-abstract-screening-stage">Title and abstract screening stage&nbsp;</h3>
<p>We used the following decision tree to make decisions about inclusion and exclusion at the Title and Abstract stage.&nbsp;</p>
<ol type="1">
<li>Is there an abstract for the article?&nbsp;</li>
</ol>
<!-- -->
<ol type="1">
<li>Yes - Go to 3.&nbsp;</li>
</ol>
<!-- -->
<ol start="2" type="1">
<li>No - Go to 2&nbsp;</li>
</ol>
<!-- -->
<ol start="2" type="1">
<li>Can you find the abstract online? (Use google.com or Google Scholar to search for the title of the article)&nbsp;</li>
</ol>
<!-- -->
<ol type="1">
<li>Yes - Enter the url for the website where you found the abstract in the ‘Add note’ box&nbsp; and Go to 3&nbsp;</li>
</ol>
<!-- -->
<ol start="2" type="1">
<li>No – Add/select ‘Abstract not found online’&nbsp; in the ‘Exclude with Reason’ box.&nbsp;</li>
</ol>
<!-- -->
<ol start="3" type="1">
<li>Is the abstract in English/Norwegian/Danish/Swedish?&nbsp;</li>
</ol>
<!-- -->
<ol type="1">
<li>Yes - Go to 4.&nbsp;</li>
</ol>
<!-- -->
<ol start="2" type="1">
<li>No – Add/select ‘Abstract not in English/Norwegian/Danish/Swedish’&nbsp; in the ‘Exclude with Reason’ box.&nbsp;</li>
</ol>
<!-- -->
<ol start="4" type="1">
<li>Does the abstract represent a research study focused on Galliformes?&nbsp;</li>
</ol>
<!-- -->
<ol type="1">
<li>Yes - Go to 5&nbsp;</li>
</ol>
<!-- -->
<ol start="2" type="1">
<li>No – Add/select ‘Not Galliformes’&nbsp; in the ‘Exclude with Reason’ box.&nbsp;</li>
</ol>
<!-- -->
<ol start="5" type="1">
<li>Does the study document the effects of legal and/or managed harvest on Galliformes populations?&nbsp;</li>
</ol>
<!-- -->
<ol type="1">
<li>Yes -&nbsp; Go&nbsp; to 6&nbsp;</li>
</ol>
<!-- -->
<ol start="2" type="1">
<li>No – Add/select ‘Not Hunting’&nbsp; in the ‘Exclude with Reason’ box.&nbsp;</li>
</ol>
<!-- -->
<ol start="6" type="1">
<li>Are effects assessed quantitatively?&nbsp;</li>
</ol>
<!-- -->
<ol type="1">
<li>Yes – Press the include button&nbsp;</li>
</ol>
<!-- -->
<ol start="2" type="1">
<li>No - Add/select ‘Not quantitative’&nbsp; in the ‘Exclude with Reason’ box.&nbsp;&nbsp;&nbsp;</li>
</ol>
<p>Conflicts between reviewers will be resolved in a group discussion with the final decision being made by EBN.&nbsp;&nbsp;&nbsp;</p>
</section>
<section id="full-text-eligibility" class="level3">
<h3 class="anchored" data-anchor-id="full-text-eligibility">Full text eligibility&nbsp;</h3>
<p>Papers included at the Title and Abstract stage was taken forward to the full text screening stage. A RIS file of included articles was downloaded from Rayyan and added to a Zotero database. PDF versions of each paper was searched using Zotero’s “Find Available PDF” tool, ResearchGate, Google Scholar and Google. If a PDF was not available online (or was not open to us), the paper was excluded at this stage of the review. Full text papers was excluded if they are/did not:&nbsp;</p>
<ul>
<li>Written in English, Norwegian, Swedish or Danish&nbsp;&nbsp;</li>
</ul>
<!-- -->
<ul>
<li>Focus on Galliformes&nbsp;</li>
</ul>
<!-- -->
<ul>
<li>Document the effect of legal hunting on Galliformes&nbsp;</li>
</ul>
<!-- -->
<ul>
<li>Assess the effect of hunting quantitatively&nbsp;</li>
</ul>
</section>
<section id="data-coding" class="level3">
<h3 class="anchored" data-anchor-id="data-coding">Data coding&nbsp;&nbsp;</h3>
<p>From all papers that met the eligibility criteria, we extracted key variables (aka “data coding”). In addition to metadata about the publication (publication year, journal name etc) we extracted the following information from the abstract or the full-text:&nbsp;&nbsp;&nbsp;</p>
<p>Species&nbsp;</p>
<p>Study area location&nbsp;</p>
<p>Country/countries&nbsp;</p>
<p>County/counties&nbsp;</p>
<p>Municipality/municipalities&nbsp;</p>
<p>Study extent / size of study area&nbsp;</p>
<ul>
<li><p>Multinational&nbsp;</p></li>
<li><p>National&nbsp;</p></li>
<li><p>Regional (e.g.&nbsp;a county, a larger mountain area etc)&nbsp;</p></li>
<li><p>Local (e.g.&nbsp;a municipality or part of municipality)&nbsp;</p></li>
<li><p>Site level (&lt; 1km2)&nbsp;</p></li>
</ul>
<p>Research type&nbsp;</p>
<p>Observational&nbsp; / analyses of empirical data&nbsp;</p>
<p>Simulation based / scenario&nbsp;</p>
<p>Study design – observational studies&nbsp;</p>
<ul>
<li><p>Randomized Controlled Trials (RCTs)&nbsp;</p></li>
<li><p>Before-After-Control-Impact (BACI)&nbsp;</p></li>
<li><p>Control-Impact (CA)&nbsp;</p></li>
<li><p>Before-After (BA)&nbsp;</p></li>
<li><p>After (A)&nbsp;</p></li>
</ul>
<p>Harvest level&nbsp;</p>
<ul>
<li>Reported harvest mortality&nbsp;</li>
</ul>
<p>Assessment of additivity of harvest mortality&nbsp;</p>
<ul>
<li>Boolean (Yes / No)&nbsp;</li>
</ul>
<p>Outcome variables: EBV class&nbsp;</p>
<ul>
<li><p>Genetic composition&nbsp;</p></li>
<li><p>Species population&nbsp;</p></li>
<li><p>Species trait&nbsp;</p></li>
</ul>
<p>Outcome variable: EBV name [not exhaustive; * indicate name that is not included in original framework]&nbsp;</p>
<ul>
<li><p>Inbreeding&nbsp;</p></li>
<li><p>Effective population size&nbsp;</p></li>
<li><p>Species distribution&nbsp;</p></li>
<li><p>Species abundance&nbsp;</p></li>
<li><p>Population density *&nbsp;</p></li>
<li><p>Morphology&nbsp;</p></li>
<li><p>Physiology&nbsp;</p></li>
<li><p>Movement rates*&nbsp;</p></li>
<li><p>Habitat use / selection*&nbsp;</p></li>
<li><p>Reproduction&nbsp;&nbsp;</p></li>
<li><p>Survival*&nbsp;</p></li>
<li><p>Sex- and age structure*&nbsp;</p></li>
</ul>
</section>
</section>
<section id="results-from-the-literature-review" class="level2">
<h2 class="anchored" data-anchor-id="results-from-the-literature-review">Results from the literature review</h2>
<p>Insert text and figures here…</p>
</section>
</section>
<section id="experimental-design" class="level1">
<h1>Experimental design</h1>
<section id="glossary-of-terms" class="level3">
<h3 class="anchored" data-anchor-id="glossary-of-terms">Glossary of terms</h3>
<section id="general-terms" class="level4">
<h4 class="anchored" data-anchor-id="general-terms"><strong><em>General terms</em></strong></h4>
<p><strong>Outcome variable:</strong> This is the variable of interest, the one to draw inference about. Defining the outcome is part of the planning of an experiment. In our harvest experiment, the outcome variables of interest include the effects of experimental harvest on i) survival and ii) population growth. &nbsp;&nbsp;</p>
<p><strong>Study population</strong>: The population we will draw inference about. In strict terms, this is the willow ptarmigan population within the geographical boundaries of our study. Assuming that the willow ptarmigan population in our study area respond in a similar way to harvest mortality as other populations, we can make predictions about how the response will be in other areas. By including <em>covariates</em> that affect the outcome (response to harvest) these predictions could be made more accurate and less biased.</p>
<p><strong>Statistical population</strong>: A statistical population is the set of subjects that we sample from and make inference from. In our case, the statistical population is the harvest areas that are included within the study area. One subject in the statistical population from which we draw some measurement is typically named a statistical unit or a sampling unit.</p>
<p><strong>Sampling frame:</strong> The sampling frame is the “collection” of all study subjects that are available for inclusion / sampling. A structured way of thinking about this is to think of a regular grid covering the whole study area. However, in our case the grid is not regular but consists of harvest areas of different sizes. In addition, we will have to make other adjustments to the sampling frame: i) only areas with “sufficient” line transect survey data are available for inclusion, and ii) only areas larger than a cut-off size. These adjustments and their consequences should be considered before we make the final decision, as they can induce bias (see below). &nbsp;&nbsp;</p>
<p><strong>Blocked study design</strong>: In blocked designs, the study units are grouped (blocked) by some characteristics. In a <u><em>randomized block design</em></u>, the treatment level is randomly assigned within the blocks. A block design typically means that the sample size must be larger in order to obtain the same statistical power as in non-blocked designs. &nbsp;&nbsp;&nbsp;</p>
<p><strong>Internal and external validity</strong>: The term <u><em>internal validity</em></u> refers to which extent the inference drawn from the sample, e.g.&nbsp;in terms of cause-effect relationships are true for the sample itself. The term external validity relates to which extent one can generalize from the current sample to the larger population that we usually want to make statements about. While the former in large-part is determined by the robustness of the methods and how treatment levels are assigned etc, the latter is in large-part determined by the sampling design and to which extent the included units are representative for the population. &nbsp;</p>
</section>
<section id="recruitmentinclusion-of-study-subjects" class="level4">
<h4 class="anchored" data-anchor-id="recruitmentinclusion-of-study-subjects">Recruitment/inclusion of study subjects</h4>
<p>The rules or algorithms chosen when recruiting / including study subjects. Since we cannot usually measure all subjects in the population, this usually involves some form of probabilistic or non-probabilistic sampling. Should be constructed to minimize the potential for <em>biased</em> estimates of inference. For instance, if all included subjects share a common characteristic that is not shared with other members of the statistical population, then the results might be biased. This is termed selection bias. Selection bias occurs whenever the subjects that are included in the study systematically deviate from the study population. Note that selection bias might also apply when assigning treatment level to a study unit in an experiment (covered below). &nbsp;</p>
<p><strong>Probabilistic sampling to recruit study subjects:</strong> This involves using recruiting units into the study by some sort of random (probabilistic) sampling. In the basic form (i.e.&nbsp;<u><em>random sampling</em></u>), all units have the same probability of being recruited. In <u><em>stratified random sampling</em></u>, the units are sorted along one or more covariates to ensure all values along the covariate are represented with a certain proportion in the sample. Under proportional stratification, all “strata” are represented with a proportion that is similar to their proportion in the statistical population. Under balanced stratification, the number of recruited units are balanced (e.g.&nbsp;similar) across strata. Under <u><em>restricted random sampling</em></u>, the initial sampling might be random but it is combined with rules that make the next decisions non-probabilistic. Examples include “do not include units that are located next to each other” etc. Another sampling strategy that combines probabilistic and non-probabilistic sampling is <u><em>systematic sampling</em></u> when the selection of the first unit is decided by a random draw.</p>
<p><strong>Non-probabilistic selection to recruit study subjects:</strong> These approaches include methods that use non-probabilistic criteria to select study subjects. Such criteria could include geography, certain characteristics (i.e - placement along a covariate axis but with no random selection – as opposed to stratified random sampling) and expert knowledge. A very specific type of non-probabilistic selection is <u><em>convenience sampling</em></u> where the units that for some reason are “easiest” to include are selected. One method that further resembles “stratified random sampling” is what is often termed <u><em>proportional quota sampling</em></u> in the medical literature. Here, the number of units that are included are proportional to the size of the strata, but the selection of units to include are not done at random. In cases when the total size of the population from which to draw sampling units from is unknown, this method will be known as <u><em>non-proportional quota sampling</em></u>. Finally, <em>purposive sampling</em> is a rather broad class of approaches where each study unit is recruited into the study based on one or more specific characteristics. In strict terms, a non-probabilistic selection of study subjects does not rely on a sampling frame. &nbsp;&nbsp;</p>
</section>
<section id="assignment-of-treatment-level-to-each-study-unit" class="level4">
<h4 class="anchored" data-anchor-id="assignment-of-treatment-level-to-each-study-unit">Assignment of treatment level to each study unit &nbsp;</h4>
<p>In manipulative experiments, there also need to be rules for assigning treatment level to the study subjects. This can be done by <u><em>random assignment</em></u> or non-random (<u><em>quasi random</em></u>) assignment. Under <u><em>random assignment</em></u> of experimental treatment level the treatment level (or control vs treatment) is randomly assigned to each unit. This is efficient in terms of assuring internal validity, as there will be no confounding effects from covariates. In <u><em>blocked designs</em></u>, treatment levels are randomly assigned within blocks. In a <u><em>crossover study</em></u> or trial, each study subject obtains a series of treatments allocated at random. In most cases, the study is designed so that all included subjects receive all treatments in a random order. This will result in a <u><em>balanced study design</em></u>, where the number of observations for each treatment are the same. This is in contrast to parallel studies or non-crossover studies where each unit is exposed to only one treatment level. For heterogenous samples, one advantage (depending on the analyses methods) is that each study subject can serve as their own control. &nbsp;&nbsp;&nbsp;</p>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>